import { createClient } from '@supabase/supabase-js'
import { MercadoPagoService } from './mercadoPagoService'

const supabaseUrl = (process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL)!.replace(/['"]/g, '')
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!.replace(/['"]/g, '')
const supabase = createClient(supabaseUrl, supabaseKey)
const mercadoPagoService = new MercadoPagoService()

export interface BotPersonality {
  id: string
  business_id: string
  bot_name: string
  tone: string
  personality_description: string
  welcome_message: string
  goodbye_message: string
  fallback_message: string
  out_of_hours_message: string
  capabilities: string[]
  reservation_settings: any
}

export interface BusinessInfo {
  id: string
  name: string
  description?: string
  address?: string
  phone?: string
  email?: string
  instagram_url?: string
  location_url?: string
  transfer_alias?: string
  working_hours?: any
  categories?: string[]
  specialties?: string[]
}

export interface ConversationContext {
  id?: string
  customer_phone: string
  business_id: string
  customer_name?: string
  reservation_day?: string
  reservation_time?: string
  reservation_type?: string
  reservation_people?: number
  context_data?: any
  created_at?: string
  updated_at?: string
  expires_at?: string
}

export class BotService {
  constructor() {
    // No need for external dependencies
  }

  async processMessage(messageText: string, customerNumber: string, businessId: string, customerName?: string, transferNumber?: string | null): Promise<string> {
    try {
      // Get bot personality and business info
      const [botPersonality, businessInfo] = await Promise.all([
        this.getBotPersonality(businessId),
        this.getBusinessInfo(businessId)
      ])

      if (!botPersonality || !businessInfo) {
        return 'Lo siento, el servicio no est√° disponible en este momento.'
      }

      // Durante las pruebas, siempre responder normalmente
      // TODO: Descomentar cuando quieras activar horarios
      /*
      if (!this.isBusinessOpen(businessInfo.working_hours)) {
        return botPersonality.out_of_hours_message
      }
      */

      // Check if this is a name registration message for a new customer
      const isNameRegistration = this.isNameRegistrationMessage(messageText, customerName)
      if (isNameRegistration) {
        const extractedName = this.extractNameFromMessage(messageText)
        if (extractedName) {
          // Save new customer to database
          const customerId = await this.saveCustomer(customerNumber, extractedName, businessId)
          if (customerId) {
            return `¬°Perfecto ${extractedName}! Ya te tengo registrado en nuestro sistema. ¬øEn qu√© te puedo ayudar hoy?`
          } else {
            return `¬°Perfecto ${extractedName}! ¬øEn qu√© te puedo ayudar hoy?`
          }
        }
      }

      // Try to get customer name from database if not provided
      if (!customerName || customerName === 'Cliente') {
        try {
          const { data: customer } = await supabase
            .from('customers')
            .select('name')
            .eq('phone', customerNumber)
            .eq('business_id', businessId)
            .single()
          
          if (customer?.name) {
            customerName = customer.name
          }
        } catch (error) {
          // Customer not found, will use provided name or 'Cliente'
        }
      }

      // Get or create conversation context
      let context = await this.getConversationContext(customerNumber, businessId)

      // Check if this is a new conversation that should reset context
      if (this.isNewConversation(messageText, context)) {
        // Clear existing context for new conversation
        await this.clearConversationContext(customerNumber, businessId)
        context = null
      }

      // Generate response based on message and context
      console.log(`ü§ñ DEBUG: About to call generateResponse with transferNumber:`, transferNumber)
      const response = await this.generateResponse(messageText, botPersonality, businessInfo, customerNumber, customerName, context || undefined, transferNumber)
      
      // Update conversation context based on the interaction
      await this.updateConversationContext(customerNumber, businessId, messageText, customerName, context)
      
      // Log conversation (optional)
      await this.logConversation(businessId, customerNumber, messageText, response)
      
      return response
    } catch (error: any) {
      console.error('Error processing message:', error)
      return 'Disculpa, ocurri√≥ un error. Por favor intenta nuevamente.'
    }
  }

  private async getBotPersonality(businessId: string): Promise<BotPersonality | null> {
    try {
      const { data, error } = await supabase
        .from('bot_personalities')
        .select('*')
        .eq('business_id', businessId)
        .single()

      if (error) throw error
      return data
    } catch (error: any) {
      console.error('Error getting bot personality:', error)
      return null
    }
  }

  private async getBusinessInfo(businessId: string): Promise<BusinessInfo | null> {
    try {
      const { data, error } = await supabase
        .from('businesses')
        .select('*')
        .eq('id', businessId)
        .single()

      if (error) throw error
      return data
    } catch (error: any) {
      console.error('Error getting business info:', error)
      return null
    }
  }


  private isBusinessOpen(workingHours: any): boolean {
    // Durante las pruebas, siempre consideramos que est√° abierto
    // TODO: Descomentar esta l√≥gica cuando tengas horarios configurados
    return true
    
    /*
    if (!workingHours) return true // Default to open if no hours configured

    const now = new Date()
    const currentDay = now.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase().slice(0, 3) // mon, tue, etc.
    const currentTime = now.getHours() * 60 + now.getMinutes() // minutes since midnight

    const dayHours = workingHours[currentDay]
    if (!dayHours || dayHours.closed) return false

    const openTime = this.timeToMinutes(dayHours.open)
    const closeTime = this.timeToMinutes(dayHours.close)

    return currentTime >= openTime && currentTime <= closeTime
    */
  }

  private timeToMinutes(timeString: string): number {
    const [hours, minutes] = timeString.split(':').map(Number)
    return (hours || 0) * 60 + (minutes || 0)
  }

  private async generateResponse(input: string, personality: BotPersonality, business: BusinessInfo, customerNumber: string, customerName?: string, context?: ConversationContext, transferNumber?: string | null): Promise<string> {
    const lowerInput = input.toLowerCase()

    // Extract name from message if mentioned
    let extractedName = customerName
    const nameMatch = input.match(/(?:soy|me\s+llamo|mi\s+nombre\s+es|a\s+nombre\s+de|nombre\s+de)\s+(\w+)|^(\w+)\s+(?:somos|soy)/i)
    if (nameMatch) {
      extractedName = nameMatch[1] || nameMatch[2]
      // Save the customer with extracted name
      this.saveCustomer(customerNumber, extractedName, business.id)
    }

    // Check if already greeted in this conversation
    const alreadyGreeted = context?.context_data?.greeted || false

    // *** PRIORITY CHECK: Transfer receipt detection (both text and transfer number) - MUST BE FIRST ***
    const hasTransferReceipt = this.isTransferReceipt(input, lowerInput) || (transferNumber !== null && transferNumber !== undefined)
    
    // DEBUG: Detailed logging
    console.log(`üîç TRANSFER RECEIPT DEBUG:`)
    console.log(`   - Input: "${input}"`)
    console.log(`   - Lower: "${lowerInput}"`)
    console.log(`   - isTransferReceipt result: ${this.isTransferReceipt(input, lowerInput)}`)
    console.log(`   - transferNumber received:`, transferNumber)
    console.log(`   - hasTransferNumber: ${transferNumber !== null && transferNumber !== undefined}`)
    console.log(`   - hasTransferReceipt final: ${hasTransferReceipt}`)
    console.log(`   - Context exists: ${!!context}`)
    console.log(`   - Context reservation_day: ${context?.reservation_day}`)
    console.log(`   - Context reservation_people: ${context?.reservation_people}`)

    // Transfer receipt processing (HIGHEST PRIORITY)
    if (hasTransferReceipt) {
      console.log(`üîç Processing transfer receipt with extracted name: ${extractedName}`)
      return await this.processTransferReceipt(input, business, customerNumber, extractedName, context, transferNumber)
    }

    // Use AI to detect intent and generate natural response
    const aiResponse = await this.generateAIResponse(input, personality, business, extractedName, alreadyGreeted, context)
    if (aiResponse) {
      return aiResponse
    }

    // Check for multiple intents in the same message (prioritize specific requests)
    const hasGreeting = lowerInput.includes('hola') || lowerInput.includes('buenas') || lowerInput.includes('buenos d√≠as') || lowerInput.includes('buenas tardes')
    
    // Enhanced reservation detection with multiple patterns FIRST
    const hasReservationKeywords = lowerInput.includes('reserva') || lowerInput.includes('mesa') || lowerInput.includes('booking')
    const hasReservationVerbs = lowerInput.includes('reservar') || lowerInput.includes('reservemos') || lowerInput.includes('reservo')
    const hasReservationIntent = (lowerInput.includes('quisiera') || lowerInput.includes('quiero') || lowerInput.includes('queremos') || lowerInput.includes('me gustaria')) && 
                               (hasReservationKeywords || hasReservationVerbs)
    const hasPositiveReservationResponse = (lowerInput.includes('dale') || lowerInput.includes('genial') || lowerInput.includes('perfecto') || lowerInput.includes('barbaro') || lowerInput.includes('b√°rbaro') || lowerInput.includes('si') || lowerInput.includes('s√≠')) &&
                                         (hasReservationKeywords || hasReservationVerbs || lowerInput.includes('reservemos') || lowerInput.includes('reserva'))
    const hasReservation = hasReservationKeywords || hasReservationVerbs || hasReservationIntent || hasPositiveReservationResponse
    
    // Hours request (but NOT if it's clearly a reservation with time)
    const hasHoursRequest = (lowerInput.includes('horario') || lowerInput.includes('abierto') || lowerInput.includes('cerrado') ||
                            (lowerInput.includes('hora') && !hasReservation)) // Only detect "hora" if it's not a reservation
    const hasLocationRequest = lowerInput.includes('ubicacion') || lowerInput.includes('direccion') || lowerInput.includes('donde') || lowerInput.includes('como llegar')
    const hasContactRequest = lowerInput.includes('contacto') || lowerInput.includes('telefono') || lowerInput.includes('llamar')
    const hasMenuRequest = lowerInput.includes('menu') || lowerInput.includes('comida') || lowerInput.includes('carta') || lowerInput.includes('platos')
    const hasLoyaltyRequest = (lowerInput.includes('puntos') || lowerInput.includes('fidelidad') || lowerInput.includes('loyalty')) && 
                             !lowerInput.includes('precio') && !lowerInput.includes('costo') && !lowerInput.includes('cuanto sale') && !lowerInput.includes('cuanto cuesta')
    const hasPriceRequest = (lowerInput.includes('precio') || lowerInput.includes('costo') || 
                           (lowerInput.includes('cuanto') && !lowerInput.includes('puntos'))) &&
                           !hasLoyaltyRequest
    
    console.log(`üîç DEBUG: lowerInput="${lowerInput}", hasLoyaltyRequest=${hasLoyaltyRequest}, hasReservation=${hasReservation}, hasTransferReceipt=${hasTransferReceipt}, hasTransferNumber=${transferNumber !== null}`)
    const hasReservationDetails = this.isReservationDetails(lowerInput)

    // Check if already greeted in this conversation (avoid repeated greetings)
    // alreadyGreeted already declared above

    // PRIORITY ORDER: Specific requests take priority over greetings

    // Hours request (highest priority for information requests)
    if (hasHoursRequest) {
      const greetingPrefix = hasGreeting && !alreadyGreeted && extractedName ? `¬°Hola ${extractedName}! ` : 
                           hasGreeting && !alreadyGreeted ? '¬°Hola! ' : ''
      const response = this.generateBusinessHoursResponse(business)
      return greetingPrefix + response
    }

    // Location request
    if (hasLocationRequest) {
      const greetingPrefix = hasGreeting && !alreadyGreeted && extractedName ? `¬°Hola ${extractedName}! ` : 
                           hasGreeting && !alreadyGreeted ? '¬°Hola! ' : ''
      const response = `üìç **¬°Ac√° estamos!**

üè† ${business.address || 'Direcci√≥n no configurada'}
üó∫Ô∏è F√°cil de llegar

üöó Tenemos estacionamiento propio
üöå Lleg√°s f√°cil en colectivo

¬øNecesit√°s que te ayude con algo m√°s?`
      return greetingPrefix + response
    }

    // Contact request  
    if (hasContactRequest) {
      const greetingPrefix = hasGreeting && !alreadyGreeted && extractedName ? `¬°Hola ${extractedName}! ` : 
                           hasGreeting && !alreadyGreeted ? '¬°Hola! ' : ''
      const response = `üìû **¬°Contactanos cuando quieras!**

üì± WhatsApp: ${business.phone || 'No configurado'}
üìß Email: ${business.email || 'No configurado'}
üìç ${business.address || 'Direcci√≥n no configurada'}

Tambi√©n pod√©s seguir escribiendo ac√° que te contesto al toque. ¬øEn qu√© m√°s te ayudo?`
      return greetingPrefix + response
    }

    // Loyalty points request (before prices!)
    if (hasLoyaltyRequest) {
      console.log('üéØ Loyalty request detected for customer:', customerNumber)
      if (personality.capabilities.includes('puntos')) {
        console.log('üîç Calling getLoyaltyPointsResponse...')
        // Try to get actual points if we have customer info
        const loyaltyResponse = await this.getLoyaltyPointsResponse(customerNumber, business.id)
        console.log('üìä Loyalty response received:', loyaltyResponse ? 'SUCCESS' : 'NULL')
        if (loyaltyResponse) {
          return loyaltyResponse
        }
        
        console.log('‚ö†Ô∏è Using fallback response - customer not found or error occurred')
        // Fallback if customer not found
        const response = `üéÅ **¬°Sos parte de nuestro club!**

Con cada consumo sum√°s puntos que pod√©s canjear por:
‚Ä¢ Descuentos en tu pr√≥xima visita
‚Ä¢ Tragos gratis  
‚Ä¢ Entradas sin cargo para el baile

¬°Hac√© tu reserva para venir al local y consultar tus puntos!`
        return response
      }
    }

    // Menu request
    if (hasMenuRequest) {
      const greetingPrefix = hasGreeting && !alreadyGreeted && extractedName ? `¬°Hola ${extractedName}! ` : 
                           hasGreeting && !alreadyGreeted ? '¬°Hola! ' : ''
      const response = `üçΩÔ∏è **¬°Nuestra carta est√° buen√≠sima!**

ü•© Especialidades: Asados, parrilla, empanadas mendocinas
üçï Pizzas artesanales con masa madre
üç∏ Tragos de autor y cervezas artesanales
üßÄ Picadas para compartir

¬øQuer√©s hacer una reserva para venir a probar? Te ayudo al toque.`
      return greetingPrefix + response
    }

    // Price request
    if (hasPriceRequest) {
      const greetingPrefix = hasGreeting && !alreadyGreeted && extractedName ? `¬°Hola ${extractedName}! ` : 
                           hasGreeting && !alreadyGreeted ? '¬°Hola! ' : ''
      const response = `üí∞ **Precios s√∫per accesibles:**

üçΩÔ∏è **Para cenar:** $15.000 - $30.000 por persona
üéâ **Entrada baile:** $8.000 (incluye un trago)
üç∏ **Tragos:** desde $4.000
üçï **Pizzas:** $8.000 - $12.000

¬°Aceptamos efectivo, d√©bito y cr√©dito! ¬øHacemos la reserva?`
      return greetingPrefix + response
    }

    // If both greeting and reservation request, prioritize reservation but acknowledge greeting
    if (hasGreeting && (hasReservation || hasReservationDetails)) {
      if (!alreadyGreeted) {
        const greetingPrefix = extractedName ? `¬°Hola ${extractedName}! ` : '¬°Hola! '
        const presentation = `Soy ${personality.bot_name || 'el asistente'} de ${business.name}. `
        const reservationResponse = await this.processReservationDetails(input, business, customerNumber, extractedName, context)
        
        // If the reservation response starts with "¬°Dale!" or similar, modify it to flow better
        if (reservationResponse.startsWith('¬°Dale!') || reservationResponse.startsWith('¬°B√°rbaro!')) {
          return greetingPrefix + presentation + 'Dale, ' + reservationResponse.substring(reservationResponse.indexOf(' ') + 1)
        } else {
          return greetingPrefix + presentation + reservationResponse
        }
      } else {
        const reservationResponse = await this.processReservationDetails(input, business, customerNumber, extractedName, context)
        return reservationResponse
      }
    }

    // If only greeting and hasn't been greeted before
    if (hasGreeting && !alreadyGreeted) {
      const greeting = extractedName ? `¬°Hola ${extractedName}! ` : '¬°Hola! '
      return greeting + `Soy ${personality.bot_name || 'el asistente virtual'} de ${business.name}. ¬øEn qu√© te puedo ayudar hoy?`
    }

    // If only greeting but already greeted before, just acknowledge briefly
    if (hasGreeting && alreadyGreeted) {
      return `¬°Hola de nuevo! ¬øEn qu√© m√°s te puedo ayudar?`
    }

    // If reservation request without details
    if (hasReservation && !hasReservationDetails) {
      if (personality.capabilities.includes('reservas')) {
        return `¬°Dale! Te ayudo con la reserva para ${business.name}. 

Para confirmar tu reserva necesito:
üìÖ ¬øPara qu√© d√≠a la quer√©s?
üë• ¬øCu√°ntas personas van a ser?
üçΩÔ∏è ¬øEs para cenar o para el baile?

Decime los datos y te la confirmo al toque.`
      }
    }

    // Advanced reservation processing with specific details
    if (hasReservationDetails) {
      return await this.processReservationDetails(input, business, customerNumber, extractedName, context)
    }

    // Business hours
    if (lowerInput.includes('horario') || lowerInput.includes('hora') || lowerInput.includes('abierto') || lowerInput.includes('cerrado')) {
      return this.generateBusinessHoursResponse(business)
    }

    // Location
    if (lowerInput.includes('ubicacion') || lowerInput.includes('direccion') || lowerInput.includes('donde') || lowerInput.includes('como llegar')) {
      return `üìç **¬°Ac√° estamos!**

üè† ${business.address || 'Direcci√≥n no configurada'}
üó∫Ô∏è F√°cil de llegar

üöó Tenemos estacionamiento propio
üöå Lleg√°s f√°cil en colectivo

¬øNecesit√°s que te ayude con algo m√°s?`
    }


    // Menu
    if (lowerInput.includes('menu') || lowerInput.includes('comida') || lowerInput.includes('carta') || lowerInput.includes('platos')) {
      return `üçΩÔ∏è **¬°Nuestra carta est√° buen√≠sima!**

ü•© Especialidades: Asados, parrilla, empanadas mendocinas
üçï Pizzas artesanales con masa madre
üç∏ Tragos de autor y cervezas artesanales
üßÄ Picadas para compartir

¬øQuer√©s hacer una reserva para venir a probar? Te ayudo al toque.`
    }

    // Prices
    if (lowerInput.includes('precio') || lowerInput.includes('costo') || lowerInput.includes('cuanto') || lowerInput.includes('valor')) {
      return `üí∞ **Precios s√∫per accesibles:**

üçΩÔ∏è **Para cenar:** $15.000 - $30.000 por persona
üéâ **Entrada baile:** $8.000 (incluye un trago)
üç∏ **Tragos:** desde $4.000
üçï **Pizzas:** $8.000 - $12.000

¬°Aceptamos efectivo, d√©bito y cr√©dito! ¬øHacemos la reserva?`
    }

    // Events
    if (lowerInput.includes('evento') || lowerInput.includes('baile') || lowerInput.includes('fiesta') || lowerInput.includes('show')) {
      return `üéâ **¬°Los findes son una locura ac√°!**

üéµ Viernes: M√∫sica en vivo + DJ
üíÉ S√°bados: Noche de baile hasta las 4am
üéä Eventos especiales todos los meses

¬øTe copa venir este finde? Te hago la reserva ahora mismo.`
    }

    // Contact
    if (lowerInput.includes('contacto') || lowerInput.includes('telefono') || lowerInput.includes('llamar')) {
      return `üìû **¬°Contactanos cuando quieras!**

üì± WhatsApp: ${business.phone || 'No configurado'}
üìß Email: ${business.email || 'No configurado'}
üìç ${business.address || 'Direcci√≥n no configurada'}

Tambi√©n pod√©s seguir escribiendo ac√° que te contesto al toque. ¬øEn qu√© m√°s te ayudo?`
    }

    // Goodbye
    if (lowerInput.includes('gracias') || lowerInput.includes('chau') || lowerInput.includes('adi√≥s') || lowerInput.includes('hasta luego')) {
      return `¬°Gracias a vos! üòä 

Nos vemos pronto en ${business.name}. ¬°Que tengas un d√≠a b√°rbaro!

¬°Chau! üëã`
    }

    // Default fallback - much more Argentine
    return `¬°Ey! No entend√≠ bien lo que me escribiste. 

Pero tranqui, te puedo ayudar con:
üçΩÔ∏è Reservas para cenar o para el baile
üìç Info sobre horarios y ubicaci√≥n  
üéÅ Consultar tus puntos de fidelidad
üí∞ Precios y promociones

¬øCon qu√© te ayudo?`
  }

  private async logConversation(businessId: string, customerNumber: string, customerMessage: string, botResponse: string): Promise<void> {
    try {
      await supabase.from('conversation_logs').insert({
        business_id: businessId,
        customer_number: customerNumber,
        customer_message: customerMessage,
        bot_response: botResponse,
        timestamp: new Date().toISOString()
      })
    } catch (error: any) {
      console.error('Error logging conversation:', error)
      // Don't throw error, just log it
    }
  }

  private isReservationDetails(input: string): boolean {
    const lowerInput = input.toLowerCase()
    
    // Don't treat phone numbers as reservation details
    if (/^\d{7,15}$/.test(input.trim()) || /^[\+\-\s\d]{8,20}$/.test(input.trim())) {
      return false
    }
    
    const reservationKeywords = [
      'viernes', 's√°bado', 'sabado', 'domingo', 'lunes', 'martes', 'mi√©rcoles', 'miercoles', 'jueves',
      'ma√±ana', 'manana', 'hoy', 'pasado ma√±ana', 'fin de semana', 'que viene', 'pr√≥ximo', 'proximo', 'este',
      'personas', 'gente', 'somos', 'vamos a ser', 'para',
      'cena', 'cenar', 'baile', 'bailar', 'fiesta',
      'para el', 'para la', 'el d√≠a', 'la noche', 'a las', ':00', 'hs'
    ]

    // Only check for small numbers (1-2 digits) in reservation context, not standalone long numbers
    const smallNumberPattern = /\b([1-9]|1[0-9]|2[0-3])\b(?=\s*(personas?|gente|hs|horas?))/i
    const timePatterns = /\d{1,2}:\d{2}|\d{1,2}\s*hs|\d{1,2}\s*horas?|a\s*las\s*\d{1,2}/i
    
    return reservationKeywords.some(keyword => lowerInput.includes(keyword)) || 
           smallNumberPattern.test(input) ||
           timePatterns.test(input)
  }

  private async processReservationDetails(input: string, business: BusinessInfo, customerNumber: string, customerName?: string, context?: ConversationContext): Promise<string> {
    // Use context information as base, then check current message for new info
    let day = context?.reservation_day || ''
    let time = context?.reservation_time || ''
    let people = context?.reservation_people?.toString() || ''
    let type = context?.reservation_type || ''
    let name = context?.customer_name || customerName || ''
    
    // If we have a valid customer name from WhatsApp profile and it's not a generic name, use it
    if (customerName && customerName !== 'Cliente' && customerName !== 'TestUser' && customerName.trim() !== '') {
      name = customerName
    }
    
    // DEBUG: Log name variables
    console.log(`üîç NAME DEBUG:`)
    console.log(`   - context?.customer_name: "${context?.customer_name}"`)
    console.log(`   - customerName parameter: "${customerName}"`)
    console.log(`   - final name variable: "${name}"`)
    console.log(`   - name check result: ${!name || name === 'Cliente' || name === 'TestUser' || name.trim() === ''}`)
    
    // DEBUG: Log name resolution
    console.log(`üîç NAME DEBUG:`)
    console.log(`   - context?.customer_name: "${context?.customer_name}"`)
    console.log(`   - customerName: "${customerName}"`)
    console.log(`   - final name: "${name}"`)
    console.log(`   - name validation: !name=${!name}, name === 'Cliente'=${name === 'Cliente'}, name === 'TestUser'=${name === 'TestUser'}, name.trim() === ''=${name.trim() === ''}`)
    

    const lowerInput = input.toLowerCase()
    
    
    // Extract day information from current message using enhanced date parsing
    const extractedDay = this.extractDateFromMessage(input)
    if (extractedDay) {
      day = extractedDay
    }

    // Extract time information from current message (overrides context)
    const timeMatch = input.match(/(\d{1,2}):(\d{2})|(\d{1,2})\s*hs|a\s*las\s*(\d{1,2})/i)
    if (timeMatch) {
      if (timeMatch[1] && timeMatch[2]) {
        time = `${timeMatch[1]}:${timeMatch[2]}hs`
      } else if (timeMatch[3]) {
        time = `${timeMatch[3]}hs`
      } else if (timeMatch[4]) {
        time = `${timeMatch[4]}hs`
      }
    }

    // Extract number of people from current message (overrides context)
    const peopleMatch = input.match(/(\d+)\s*personas?|somos\s*(\d+)|para\s*(\d+)|(\d+)\s*gente/i)
    if (peopleMatch) {
      people = peopleMatch[1] || peopleMatch[2] || peopleMatch[3] || peopleMatch[4]
    }

    // Extract type from current message (overrides context)
    if (lowerInput.includes('cena') || lowerInput.includes('cenar')) {
      type = 'cena'
    } else if (lowerInput.includes('baile') || lowerInput.includes('bailar')) {
      type = 'baile'
    } else if (time && !type) {
      // Auto-detect based on time only if not explicitly mentioned
      const hour = parseInt(time.split(':')[0])
      if (hour >= 20 && hour <= 23) {
        type = 'cena'
      } else if (hour >= 23 || hour <= 4) {
        type = 'baile'
      }
    }

    // Generate intelligent response
    if (day && type) {
      // Has day and type, check if we need people count
      if (people) {
        // Check if we have a valid customer's name
        if (!name || name === 'Cliente' || name === 'TestUser' || name.trim() === '') {
          return `¬°Perfecto! Tengo todos los datos de tu reserva:

üìÖ **${day.toUpperCase()}** ${time ? `a las ${time}` : ''}
üë• **${people} personas**  
üçΩÔ∏è **Para ${type}**

Para confirmarla solo me falta tu nombre. ¬øC√≥mo te llam√°s?`
        }
        
        // Complete reservation information - generate payment link
        const montoSe√±a = 1 * parseInt(people) // $1 peso por persona para pruebas
        
        try {
          const linkPago = await mercadoPagoService.crearLinkDePago(
            montoSe√±a,
            `Se√±a reserva - ${name} - ${day} ${time} - ${people} personas`,
            customerNumber
          )
          
          return `¬°B√°rbaro ${name}! Tengo todos los datos de tu reserva:

üìÖ **${day.toUpperCase()}** ${time ? `a las ${time}` : ''}
üë• **${people} personas**
üçΩÔ∏è **Para ${type}**

‚ö†Ô∏è **IMPORTANTE - LE√â ESTAS CONDICIONES:**

‚ö†Ô∏è Si queres asegurar tu lugar, ser√° obligatorio abonar una se√±a.
‚ö†Ô∏è Tolerancia de reserva hasta las 22hs, luego, se pierde el lugar (SIN EXCEPCI√ìN)
‚ö†Ô∏è Menores de 18 a√±os pueden permanecer en el bar hasta 1am.

üí∞ **SE√ëA REQUERIDA: $${montoSe√±a} pesos** ($1 por persona)

üîó **PAG√Å TU SE√ëA AQU√ç:**
${linkPago}

Una vez que completes el pago, se confirma tu reserva autom√°ticamente! ‚úÖ`
        } catch (error) {
          console.error('Error generando link de pago:', error)
          return `¬°B√°rbaro ${name}! Tengo todos los datos de tu reserva:

üìÖ **${day.toUpperCase()}** ${time ? `a las ${time}` : ''}
üë• **${people} personas**
üçΩÔ∏è **Para ${type}**

Hubo un problema generando el link de pago. Por favor, contacta al restaurant directamente.`
        }
      } else {
        // Missing people count
        return `¬°Dale ${name ? name : ''}! Ya tengo que es para **${day}** ${time ? `a las ${time}` : ''} **para ${type}**.

Solo me falta saber: **¬øCu√°ntas personas van a ser?**

Y te confirmo la reserva al toque.`
      }
    }
    else if (day || people || type || time) {
      // Partial information, ask for missing details
      let missing = []
      if (!day) missing.push('üìÖ ¬øPara qu√© d√≠a?')
      if (!people) missing.push('üë• ¬øCu√°ntas personas?')
      if (!type && !time) missing.push('üçΩÔ∏è ¬øPara cenar o para el baile?')

      let hasInfo = []
      if (day) hasInfo.push(`el d√≠a (${day})`)
      if (people) hasInfo.push(`la cantidad (${people} personas)`)
      if (type) hasInfo.push(`que es para ${type}`)
      if (time && !type) hasInfo.push(`el horario (${time})`)

      return `¬°Dale ${name ? name : ''}! Ya tengo ${hasInfo.join(' y ')}.

Necesito que me confirmes:
${missing.join('\n')}

As√≠ te confirmo la reserva al toque.`
    }
    else {
      // No clear reservation info found
      return `¬°Dale ${name ? name : ''}! Te ayudo con la reserva. Para confirmarla necesito:

üìÖ ¬øPara qu√© d√≠a la quer√©s? (ej: "viernes", "ma√±ana", "s√°bado")
üë• ¬øCu√°ntas personas van a ser?
üçΩÔ∏è ¬øEs para cenar o para el baile?

Contame y te la confirmo enseguida.`
    }
  }

  private async saveCustomer(phoneNumber: string, name: string, businessId?: string): Promise<string | null> {
    try {
      // Try to save or update customer in database
      const customerData = {
        phone: phoneNumber,
        name: name,
        business_id: businessId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
      
      const { data, error } = await supabase.from('customers').upsert(customerData, {
        onConflict: 'business_id,phone'
      }).select('id').single()

      if (error) {
        console.error('Error saving customer:', error)
        return null
      }
      return data?.id || null
    } catch (error: any) {
      console.error('Error saving customer:', error)
      return null
    }
  }

  private async saveReservation(businessId: string, customerPhone: string, customerName: string, day: string, time: string, type: string, people: string): Promise<boolean> {
    try {
      // First, ensure customer exists and get their ID
      const customerId = await this.saveCustomer(customerPhone, customerName, businessId)
      if (!customerId) {
        console.error('Could not create/find customer for reservation')
        return false
      }

      // Parse the reservation details
      const reservationDate = this.parseReservationDate(day, time)
      if (!reservationDate) {
        return false
      }

      // Save the reservation
      const reservationData = {
        business_id: businessId,
        customer_id: customerId,
        reservation_type: type,
        reservation_date: reservationDate.toISOString(),
        party_size: parseInt(people),
        status: 'confirmed',
        phone: customerPhone,
        customer_name: customerName,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
      
      const { data, error } = await supabase.from('reservations').insert(reservationData).select('id').single()

      if (error) {
        console.error('Error saving reservation:', error)
        return false
      }
      return true
    } catch (error: any) {
      console.error('Error saving reservation:', error)
      return false
    }
  }

  private parseReservationDate(day: string, time: string): Date | null {
    try {
      const now = new Date()
      let targetDate = new Date()

      // Parse day
      switch (day.toLowerCase()) {
        case 'hoy':
          targetDate = new Date(now)
          break
        case 'ma√±ana':
        case 'manana':
          targetDate = new Date(now)
          targetDate.setDate(now.getDate() + 1)
          break
        case 'lunes':
          targetDate = this.getNextWeekday(now, 1) // Monday = 1
          break
        case 'lunes que viene':
          targetDate = this.getNextWeekday(now, 1, true) // Next Monday
          break
        case 'martes':
          targetDate = this.getNextWeekday(now, 2) // Tuesday = 2
          break
        case 'martes que viene':
          targetDate = this.getNextWeekday(now, 2, true) // Next Tuesday
          break
        case 'mi√©rcoles':
        case 'miercoles':
          targetDate = this.getNextWeekday(now, 3) // Wednesday = 3
          break
        case 'mi√©rcoles que viene':
        case 'miercoles que viene':
          targetDate = this.getNextWeekday(now, 3, true) // Next Wednesday
          break
        case 'jueves':
          targetDate = this.getNextWeekday(now, 4) // Thursday = 4
          break
        case 'jueves que viene':
          targetDate = this.getNextWeekday(now, 4, true) // Next Thursday
          break
        case 'viernes':
          targetDate = this.getNextWeekday(now, 5) // Friday = 5
          break
        case 'viernes que viene':
          targetDate = this.getNextWeekday(now, 5, true) // Next Friday
          break
        case 's√°bado':
        case 'sabado':
          targetDate = this.getNextWeekday(now, 6) // Saturday = 6
          break
        case 's√°bado que viene':
        case 'sabado que viene':
          targetDate = this.getNextWeekday(now, 6, true) // Next Saturday
          break
        case 'domingo':
          targetDate = this.getNextWeekday(now, 0) // Sunday = 0
          break
        case 'domingo que viene':
          targetDate = this.getNextWeekday(now, 0, true) // Next Sunday
          break
        default:
          console.error('Unknown day format:', day)
          return null
      }

      // Parse time - handle formats like "20hs", "20:00hs", "8pm"
      if (time && time.trim() !== '') {
        const timeMatch = time.match(/(\d{1,2})(?::(\d{2}))?(?:hs|:00hs)?/)
        if (timeMatch) {
          const hours = parseInt(timeMatch[1])
          const minutes = parseInt(timeMatch[2] || '0')
          targetDate.setHours(hours, minutes, 0, 0)
        } else {
          console.error('Unknown time format:', time)
          return null
        }
      } else {
        // No time specified, use default time for dinner (20:00)
        targetDate.setHours(20, 0, 0, 0)
      }

      return targetDate
    } catch (error) {
      console.error('Error parsing reservation date:', error)
      return null
    }
  }

  private getNextWeekday(fromDate: Date, targetWeekday: number, forceNext: boolean = false): Date {
    const result = new Date(fromDate)
    const currentWeekday = fromDate.getDay()
    
    let daysToAdd = targetWeekday - currentWeekday
    
    if (daysToAdd <= 0 || forceNext) {
      daysToAdd += 7
    }
    
    result.setDate(fromDate.getDate() + daysToAdd)
    return result
  }

  private isNewConversation(messageText: string, existingContext: ConversationContext | null): boolean {
    if (!existingContext) {
      return false // No existing context, so not really "new"
    }

    const lowerMessage = messageText.toLowerCase()
    
    // Check if message contains greeting
    const hasGreeting = lowerMessage.includes('hola') || lowerMessage.includes('buenas') || lowerMessage.includes('buenos d√≠as') || lowerMessage.includes('buenas tardes')
    
    // Check if message has complete reservation data (name + details) OR is just providing a name when context has reservation data
    const hasCompleteReservationData = (
      (lowerMessage.includes('nombre') || lowerMessage.includes('a nombre de') || lowerMessage.match(/^\w+\s+(?:somos|para)/)) &&
      (lowerMessage.includes('persona') || lowerMessage.includes('gente') || /\d+/.test(lowerMessage)) &&
      (lowerMessage.includes('lunes') || lowerMessage.includes('martes') || lowerMessage.includes('mi√©rcoles') || lowerMessage.includes('miercoles') || lowerMessage.includes('jueves') || lowerMessage.includes('viernes') || lowerMessage.includes('s√°bado') || lowerMessage.includes('sabado') || lowerMessage.includes('domingo') || lowerMessage.includes('hoy') || lowerMessage.includes('ma√±ana') || lowerMessage.includes('manana'))
    )
    
    // Check if it's just providing a name for existing reservation context
    const isProvidingNameForReservation = (
      existingContext && 
      (existingContext.reservation_day || existingContext.reservation_people || existingContext.reservation_type) &&
      (lowerMessage.match(/^soy\s+\w+$/) || lowerMessage.match(/^me\s+llamo\s+\w+$/))
    )
    
    // Check if context has any reservation data
    const contextHasReservationData = existingContext.reservation_day || 
                                     existingContext.reservation_time || 
                                     existingContext.reservation_type || 
                                     existingContext.reservation_people

    // Check if enough time has passed (more than 15 minutes since last update)
    const lastUpdate = new Date(existingContext.updated_at || existingContext.created_at || '')
    const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000)
    const hasBeenLongTime = lastUpdate < fifteenMinutesAgo

    // It's a new conversation if:
    // 1. Has complete reservation data in a single message (new reservation)
    // 2. Has greeting AND complete reservation data AND existing context has reservation data
    // 3. Has been more than 15 minutes since last update AND has greeting AND no current reservation in progress
    // 4. NEVER reset if just providing name for existing reservation
    return (hasCompleteReservationData && !isProvidingNameForReservation) ||
           (hasGreeting && hasCompleteReservationData && contextHasReservationData && !isProvidingNameForReservation) ||
           (hasBeenLongTime && hasGreeting && !contextHasReservationData && !isProvidingNameForReservation)
  }

  private async clearConversationContext(customerPhone: string, businessId: string): Promise<void> {
    try {
      await supabase.from('conversation_context')
        .delete()
        .eq('customer_phone', customerPhone)
        .eq('business_id', businessId)
    } catch (error: any) {
      console.error('Error clearing conversation context:', error)
    }
  }

  private async generateAIResponse(input: string, personality: BotPersonality, business: BusinessInfo, customerName?: string, alreadyGreeted?: boolean, context?: ConversationContext): Promise<string | null> {
    try {
      // Don't use AI for reservation details - let specific logic handle it
      if (this.isReservationDetails(input.toLowerCase())) {
        return null
      }
      
      // Don't use AI for transfer receipts - let specific logic handle it
      if (this.isTransferReceipt(input, input.toLowerCase())) {
        console.log('üîç AI detected transfer receipt, delegating to specific logic')
        return null
      }
      
      // Prepare business information for AI
      const businessInfo = this.formatBusinessInfoForAI(business)
      const conversationHistory = context?.context_data?.messages?.slice(-3) || [] // Last 3 messages for context
      
      const prompt = `Eres ${personality.bot_name}, ${personality.personality_description}

INFORMACI√ìN DEL NEGOCIO:
${businessInfo}

PERSONALIDAD: ${personality.tone}
CLIENTE: ${customerName || 'Cliente'}
YA SE SALUDARON: ${alreadyGreeted ? 'S√≠' : 'No'}

HISTORIAL RECIENTE:
${conversationHistory.map(m => `- ${m.message} (${m.intent})`).join('\n')}

INSTRUCCIONES:
- Responde de forma natural y argentina como ${personality.bot_name}
- Si preguntan por horarios, ubicaci√≥n, contacto, precios o men√∫, usa la informaci√≥n del negocio
- Si es un saludo y ya se saludaron antes, s√© breve
- Si mencionan reserva, mesa o quieren reservar, indica que necesitas: d√≠a, hora, cantidad de personas y tipo (cena/baile)
- Usa emojis apropiados
- S√© conversacional y amigable
- NO inventes informaci√≥n que no tienes

MENSAJE DEL CLIENTE: "${input}"

RESPUESTA (m√°ximo 300 caracteres):`

      // Use a simple AI completion (you can use OpenAI API, Anthropic, or any AI service)
      // For now, I'll implement a fallback that returns null to use the rule-based system
      // But you can integrate with your preferred AI service here
      
      const aiResponse = await this.callAIService(prompt)
      return aiResponse
      
    } catch (error) {
      console.error('Error generating AI response:', error)
      return null // Fallback to rule-based system
    }
  }

  private async callAIService(prompt: string): Promise<string | null> {
    try {
      // Use a simple local AI logic for now (you can replace with external API later)
      // This is a lightweight implementation that mimics AI behavior
      return this.generateSmartResponse(prompt)
    } catch (error) {
      console.error('AI service error:', error)
      return null
    }
  }

  private generateSmartResponse(prompt: string): string | null {
    // Extract the customer message from the prompt
    const messageMatch = prompt.match(/MENSAJE DEL CLIENTE: "(.+)"/)
    if (!messageMatch) return null
    
    const message = messageMatch[1].toLowerCase()
    
    // Extract business info
    const businessName = prompt.match(/NOMBRE: (.+)/)?.[1] || 'el negocio'
    const botName = prompt.match(/Eres ([^,]+),/)?.[1] || 'el asistente'
    const alreadyGreeted = prompt.includes('YA SE SALUDARON: S√≠')
    const customerName = prompt.match(/CLIENTE: (.+)/)?.[1]
    const isCustomerNamed = customerName && customerName !== 'Cliente'
    
    // Detect intent and generate natural response
    if (message.includes('horario') || message.includes('hora') || message.includes('abierto') || message.includes('cerrado')) {
      const hoursInfo = this.extractHoursFromPrompt(prompt)
      const greeting = message.includes('hola') && !alreadyGreeted ? 
        (isCustomerNamed ? `¬°Hola ${customerName}! ` : '¬°Hola! ') : ''
      return `${greeting}üìÖ Nuestros horarios son:\n${hoursInfo}\n¬øNecesit√°s algo m√°s?`
    }
    
    if (message.includes('ubicacion') || message.includes('direccion') || message.includes('donde')) {
      const address = prompt.match(/DIRECCI√ìN: (.+)/)?.[1] || 'No tenemos direcci√≥n configurada'
      const greeting = message.includes('hola') && !alreadyGreeted ? 
        (isCustomerNamed ? `¬°Hola ${customerName}! ` : '¬°Hola! ') : ''
      return `${greeting}üìç Estamos en ${address}. ¬°Te esperamos!`
    }
    
    if (message.includes('contacto') || message.includes('telefono') || message.includes('llamar')) {
      const phone = prompt.match(/TEL√âFONO: (.+)/)?.[1] || 'No configurado'
      const email = prompt.match(/EMAIL: (.+)/)?.[1] || 'No configurado'
      const greeting = message.includes('hola') && !alreadyGreeted ? 
        (isCustomerNamed ? `¬°Hola ${customerName}! ` : '¬°Hola! ') : ''
      return `${greeting}üìû Podes contactarnos:\nüì± WhatsApp: ${phone}\nüìß Email: ${email}`
    }
    
    // Check for loyalty points BEFORE prices (priority!) - but let main logic handle detailed response
    if ((message.includes('puntos') || message.includes('fidelidad') || message.includes('loyalty')) && 
        !message.includes('precio') && !message.includes('costo') && !message.includes('cuanto sale') && !message.includes('cuanto cuesta')) {
      // Return null to let main logic handle loyalty points with actual data from database
      return null
    }
    
    if ((message.includes('precio') || message.includes('costo') || message.includes('cuanto')) && 
        !message.includes('puntos') && !message.includes('fidelidad')) {
      const greeting = message.includes('hola') && !alreadyGreeted ? 
        (isCustomerNamed ? `¬°Hola ${customerName}! ` : '¬°Hola! ') : ''
      return `${greeting}üí∞ Nuestros precios son s√∫per accesibles:\nüçΩÔ∏è Cenas: $15.000-$30.000\nüéâ Baile: $8.000\nüç∏ Tragos: desde $4.000`
    }
    
    if (message.includes('menu') || message.includes('comida') || message.includes('carta')) {
      const greeting = message.includes('hola') && !alreadyGreeted ? 
        (isCustomerNamed ? `¬°Hola ${customerName}! ` : '¬°Hola! ') : ''
      return `${greeting}üçΩÔ∏è Nuestra carta tiene:\nü•© Asados y parrilla\nüçï Pizzas artesanales\nüç∏ Tragos de autor\nüßÄ Picadas para compartir`
    }
    
    // Check if message combines greeting + reservation request with enhanced detection
    const hasGreeting = message.includes('hola') || message.includes('buenas') || 
                       message.includes('como estas') || message.includes('como andas') || 
                       message.includes('que tal') || message.includes('como va')
    const hasReservationKeywords = message.includes('reserva') || message.includes('mesa') || message.includes('booking')
    const hasReservationVerbs = message.includes('reservar') || message.includes('reservemos') || message.includes('reservo')
    const hasReservationIntent = (message.includes('quisiera') || message.includes('quiero') || message.includes('queremos') || message.includes('me gustaria')) && 
                               (hasReservationKeywords || hasReservationVerbs)
    const hasPositiveReservationResponse = (message.includes('dale') || message.includes('genial') || message.includes('perfecto') || message.includes('barbaro') || message.includes('b√°rbaro') || message.includes('si') || message.includes('s√≠')) &&
                                         (hasReservationKeywords || hasReservationVerbs || message.includes('reservemos') || message.includes('reserva'))
    const hasReservationRequest = hasReservationKeywords || hasReservationVerbs || hasReservationIntent || hasPositiveReservationResponse
    
    if (hasGreeting && hasReservationRequest) {
      // Greeting + reservation in same message - let structured flow handle but with greeting
      return null // Use structured reservation flow
    }
    
    if (hasGreeting && alreadyGreeted) {
      return `¬°Hola de nuevo! ¬øEn qu√© m√°s te puedo ayudar?`
    }
    
    if (hasGreeting && !alreadyGreeted) {
      const personalGreeting = isCustomerNamed ? `¬°Hola ${customerName}! ` : '¬°Hola! '
      return `${personalGreeting}Soy ${botName} de ${businessName}. ¬øEn qu√© te puedo ayudar hoy?`
    }
    
    // If it's about reservations only, return null to use the structured flow
    if (hasReservationRequest) {
      return null // Use structured reservation flow
    }
    
    // If it contains reservation details, return null to use structured flow
    if (this.isReservationDetails(message)) {
      return null // Use structured reservation flow
    }
    
    // Default friendly response
    return `¬°Dale! Soy ${botName} de ${businessName}. Puedo ayudarte con horarios, ubicaci√≥n, contacto, precios, men√∫ o reservas. ¬øQu√© necesit√°s?`
  }

  private extractHoursFromPrompt(prompt: string): string {
    const hoursSection = prompt.match(/HORARIOS:\n([\s\S]*?)(?:\n[A-Z]+:|$)/)?.[1]
    if (!hoursSection) return 'No tenemos horarios configurados'
    
    // Only process lines that are actual schedule lines (start with "- ")
    const lines = hoursSection.split('\n')
      .filter(line => line.trim() && line.startsWith('- '))
      .map(line => line.replace('- ', ''))
    
    if (lines.length === 0) return 'No tenemos horarios configurados'
    
    const openDays = lines.filter(line => !line.includes('CERRADO'))
    const closedDays = lines.filter(line => line.includes('CERRADO')).map(line => line.split(':')[0])
    
    let result = ''
    if (openDays.length > 0) {
      result += 'üü¢ ABIERTO:\n' + openDays.map(day => `- ${day}`).join('\n') + '\n'
    }
    if (closedDays.length > 0) {
      result += 'üî¥ CERRADO: ' + closedDays.join(', ')
    }
    
    return result
  }

  private formatBusinessInfoForAI(business: BusinessInfo): string {
    let info = `NOMBRE: ${business.name}\n`
    
    if (business.address) {
      info += `DIRECCI√ìN: ${business.address}\n`
    }
    
    if (business.phone) {
      info += `TEL√âFONO: ${business.phone}\n`
    }
    
    if (business.email) {
      info += `EMAIL: ${business.email}\n`
    }
    
    if (business.working_hours) {
      info += `HORARIOS:\n`
      const hours = business.working_hours
      const dayNames = {
        monday: 'Lunes', tuesday: 'Martes', wednesday: 'Mi√©rcoles',
        thursday: 'Jueves', friday: 'Viernes', saturday: 'S√°bado', sunday: 'Domingo'
      }
      
      Object.entries(hours).forEach(([day, schedule]: [string, any]) => {
        const dayName = dayNames[day as keyof typeof dayNames]
        if (schedule.closed) {
          info += `- ${dayName}: CERRADO\n`
        } else {
          info += `- ${dayName}: ${schedule.open} a ${schedule.close}\n`
        }
      })
    }
    
    if (business.description) {
      info += `DESCRIPCI√ìN: ${business.description}\n`
    }
    
    return info
  }

  private detectIntent(lowerInput: string): string {
    if (lowerInput.includes('horario') || lowerInput.includes('hora') || lowerInput.includes('abierto') || lowerInput.includes('cerrado')) {
      return 'horarios'
    }
    if (lowerInput.includes('ubicacion') || lowerInput.includes('direccion') || lowerInput.includes('donde') || lowerInput.includes('como llegar')) {
      return 'ubicacion'
    }
    if (lowerInput.includes('contacto') || lowerInput.includes('telefono') || lowerInput.includes('llamar')) {
      return 'contacto'
    }
    if (lowerInput.includes('reserva') || lowerInput.includes('mesa') || lowerInput.includes('booking') || lowerInput.includes('quisiera') || lowerInput.includes('quiero')) {
      return 'reserva'
    }
    if (lowerInput.includes('hola') || lowerInput.includes('buenas') || lowerInput.includes('buenos d√≠as') || lowerInput.includes('buenas tardes')) {
      return 'saludo'
    }
    if (lowerInput.includes('gracias') || lowerInput.includes('chau') || lowerInput.includes('adi√≥s')) {
      return 'despedida'
    }
    return 'general'
  }

  private generateBusinessHoursResponse(business: BusinessInfo): string {
    if (!business.working_hours) {
      return `üìÖ **Horarios de ${business.name}:**

No tenemos horarios configurados en el sistema. 
Por favor contactanos para m√°s informaci√≥n.`
    }

    const hours = business.working_hours
    const dayNames = {
      monday: 'Lunes',
      tuesday: 'Martes', 
      wednesday: 'Mi√©rcoles',
      thursday: 'Jueves',
      friday: 'Viernes',
      saturday: 'S√°bado',
      sunday: 'Domingo'
    }

    let openDays = []
    let closedDays = []

    Object.entries(hours).forEach(([day, schedule]: [string, any]) => {
      const dayName = dayNames[day as keyof typeof dayNames]
      if (schedule.closed) {
        closedDays.push(dayName)
      } else {
        openDays.push(`‚Ä¢ **${dayName}**: ${schedule.open} a ${schedule.close}hs`)
      }
    })

    let response = `üìÖ **Horarios de ${business.name}:**\n\n`
    
    if (openDays.length > 0) {
      response += `üü¢ **ABIERTO:**\n${openDays.join('\n')}\n\n`
    }
    
    if (closedDays.length > 0) {
      response += `üî¥ **CERRADO:** ${closedDays.join(', ')}\n\n`
    }

    response += `¬øNecesit√°s algo m√°s?`
    
    return response
  }

  private async getConversationContext(customerPhone: string, businessId: string): Promise<ConversationContext | null> {
    try {
      // Clean up expired contexts first
      await supabase.from('conversation_context')
        .delete()
        .lt('expires_at', new Date().toISOString())

      // Get current conversation context
      const { data, error } = await supabase
        .from('conversation_context')
        .select('*')
        .eq('customer_phone', customerPhone)
        .eq('business_id', businessId)
        .single()

      if (error) {
        // No context exists yet
        return null
      }

      return data
    } catch (error: any) {
      console.error('Error getting conversation context:', error)
      return null
    }
  }

  private isNameRegistrationMessage(messageText: string, currentCustomerName?: string): boolean {
    // Only consider it name registration if we don't have a customer name yet
    if (currentCustomerName && currentCustomerName !== 'Cliente') {
      return false
    }

    const lowerMessage = messageText.toLowerCase().trim()
    
    // Exclude common greetings and other words that aren't names
    const excludedWords = ['hola', 'buenas', 'buenos', 'tardes', 'dias', 'noches', 'que', 'tal', 'como', 'estas', 'gracias', 'si', 'no', 'ok', 'bien', 'mal']
    if (excludedWords.includes(lowerMessage)) {
      return false
    }
    
    // Common patterns for name registration
    const namePatterns = [
      /^soy\s+([a-z√°√©√≠√≥√∫√±]+)$/i,
      /^me\s+llamo\s+([a-z√°√©√≠√≥√∫√±]+)$/i,
      /^mi\s+nombre\s+es\s+([a-z√°√©√≠√≥√∫√±]+)$/i,
      /^([a-z√°√©√≠√≥√∫√±]+)$/i // Just a single name
    ]

    return namePatterns.some(pattern => pattern.test(messageText)) && 
           messageText.trim().split(' ').length <= 2 && // Max 2 words for name
           !excludedWords.includes(lowerMessage.split(' ')[0]) // First word isn't a common word
  }

  private extractNameFromMessage(messageText: string): string | null {
    const excludedWords = ['hola', 'buenas', 'buenos', 'tardes', 'dias', 'noches', 'que', 'tal', 'como', 'estas', 'gracias', 'si', 'no', 'ok', 'bien', 'mal']
    
    const patterns = [
      /soy\s+([a-z√°√©√≠√≥√∫√±]+)/i,
      /me\s+llamo\s+([a-z√°√©√≠√≥√∫√±]+)/i,
      /mi\s+nombre\s+es\s+([a-z√°√©√≠√≥√∫√±]+)/i,
      /^([a-z√°√©√≠√≥√∫√±]+)$/i // Just a single name
    ]

    for (const pattern of patterns) {
      const match = messageText.match(pattern)
      if (match && match[1]) {
        const name = match[1].toLowerCase()
        // Don't extract if it's a common word/greeting
        if (excludedWords.includes(name)) {
          return null
        }
        // Capitalize first letter
        return match[1].charAt(0).toUpperCase() + match[1].slice(1).toLowerCase()
      }
    }

    return null
  }

  private async getLoyaltyPointsResponse(customerPhone: string, businessId: string): Promise<string | null> {
    try {
      console.log(`Getting loyalty points for phone: ${customerPhone}, business: ${businessId}`)
      
      // Get customer points directly from database with timeout
      const customerQuery = supabase
        .from('customers')
        .select('id, name, points')
        .eq('phone', customerPhone)
        .eq('business_id', businessId)
        .single()

      // Add timeout to prevent hanging
      const customerResult = await Promise.race([
        customerQuery,
        new Promise((_, reject) => setTimeout(() => reject(new Error('Query timeout')), 3000))
      ]) as any

      if (customerResult.error) {
        console.error('Error fetching customer for loyalty:', customerResult.error)
        return null
      }

      const customer = customerResult.data
      console.log('Customer found for loyalty:', customer)

      if (!customer) {
        return null
      }

      const customerPoints = customer.points || 0
      
      // Get redeemable items from database
      const redeemableItemsQuery = supabase
        .from('redeemable_items')
        .select('name, points_required, description')
        .eq('business_id', businessId)
        .eq('is_available', true)
        .order('points_required', { ascending: true })
        .limit(10)

      const redeemableItemsResult = await Promise.race([
        redeemableItemsQuery,
        new Promise((_, reject) => setTimeout(() => reject(new Error('Query timeout')), 3000))
      ]) as any

      let redeemableItemsText = '‚Ä¢ Descuentos en tu pr√≥xima visita\n‚Ä¢ Tragos gratis\n‚Ä¢ Entradas sin cargo para el baile'
      
      if (!redeemableItemsResult.error && redeemableItemsResult.data && redeemableItemsResult.data.length > 0) {
        const items = redeemableItemsResult.data
        redeemableItemsText = items.map((item: any) => `‚Ä¢ ${item.name} (${item.points_required} puntos)`).join('\n')
      }
      
      let loyaltyMessage = `üíé **Ten√©s ${customerPoints} puntos acumulados**

üéÅ **Con tus puntos pod√©s canjear:**
${redeemableItemsText}

¬°Hac√© tu reserva para venir al local y canjear tus puntos!`

      return loyaltyMessage

    } catch (error) {
      console.error('Error fetching loyalty points:', error)
      return null
    }
  }

  private async updateConversationContext(customerPhone: string, businessId: string, messageText: string, customerName?: string, existingContext?: ConversationContext | null): Promise<void> {
    try {
      const lowerInput = messageText.toLowerCase()
      
      // Extract reservation details from message
      const extractedData: Partial<ConversationContext> = {}

      // Extract name if mentioned
      const nameMatch = messageText.match(/soy\s+(\w+)|me\s+llamo\s+(\w+)|mi\s+nombre\s+es\s+(\w+)/i)
      if (nameMatch) {
        extractedData.customer_name = nameMatch[1] || nameMatch[2] || nameMatch[3]
      } else if (customerName) {
        extractedData.customer_name = customerName
      }

      // Update conversation memory in context_data
      const currentContextData = existingContext?.context_data || {}
      const messageHistory = currentContextData.messages || []
      
      // Add current message to history (keep last 10 messages)
      messageHistory.push({
        message: messageText,
        timestamp: new Date().toISOString(),
        intent: this.detectIntent(lowerInput)
      })
      if (messageHistory.length > 10) {
        messageHistory.shift() // Remove oldest message
      }

      // Mark as greeted if this message contains greeting
      const hasGreeting = lowerInput.includes('hola') || lowerInput.includes('buenas') || lowerInput.includes('buenos d√≠as') || lowerInput.includes('buenas tardes')
      
      extractedData.context_data = {
        ...currentContextData,
        messages: messageHistory,
        greeted: currentContextData.greeted || hasGreeting,
        lastMessageTime: new Date().toISOString()
      }

      // Extract day information - Enhanced date parsing
      const extractedDay = this.extractDateFromMessage(messageText)
      if (extractedDay) {
        extractedData.reservation_day = extractedDay
      }

      // Extract time information
      const timeMatch = messageText.match(/(\d{1,2}):(\d{2})|(\d{1,2})\s*hs|a\s*las\s*(\d{1,2})/i)
      if (timeMatch) {
        if (timeMatch[1] && timeMatch[2]) {
          extractedData.reservation_time = `${timeMatch[1]}:${timeMatch[2]}hs`
        } else if (timeMatch[3]) {
          extractedData.reservation_time = `${timeMatch[3]}:00hs`
        } else if (timeMatch[4]) {
          extractedData.reservation_time = `${timeMatch[4]}:00hs`
        }
      }

      // Extract number of people (but avoid phone numbers)
      const peopleMatch = messageText.match(/(\d+)\s*personas?|somos\s*(\d+)|para\s*(\d+)|(\d+)\s*gente/i)
      if (peopleMatch) {
        const people = parseInt(peopleMatch[1] || peopleMatch[2] || peopleMatch[3] || peopleMatch[4])
        // Only consider it people count if it's reasonable and not a phone number
        if (people && people > 0 && people <= 50 && people.toString().length <= 2) {
          extractedData.reservation_people = people
        }
      }

      // Extract type (cena or baile)
      if (lowerInput.includes('cena') || lowerInput.includes('cenar')) {
        extractedData.reservation_type = 'cena'
      } else if (lowerInput.includes('baile') || lowerInput.includes('bailar')) {
        extractedData.reservation_type = 'baile'
      } else if (extractedData.reservation_time) {
        // Auto-detect based on time
        const hour = parseInt(extractedData.reservation_time.split(':')[0])
        if (hour >= 20 && hour <= 23) {
          extractedData.reservation_type = 'cena'
        } else if (hour >= 23 || hour <= 4) {
          extractedData.reservation_type = 'baile'
        }
      }

      // Only update context if we have new information
      if (Object.keys(extractedData).length === 0 && !existingContext) {
        return
      }

      // Merge with existing context
      const contextData = {
        customer_phone: customerPhone,
        business_id: businessId,
        ...existingContext,
        ...extractedData,
        expires_at: new Date(Date.now() + 15 * 60 * 1000).toISOString() // 15 minutes from now
      }

      // Upsert conversation context
      await supabase.from('conversation_context').upsert(contextData, {
        onConflict: 'customer_phone,business_id'
      })

    } catch (error: any) {
      console.error('Error updating conversation context:', error)
      // Don't throw error, just log it
    }
  }

  // Function to detect transfer receipts
  private isTransferReceipt(input: string, lowerInput: string): boolean {
    // Keywords that indicate a transfer receipt
    const receiptKeywords = [
      'comprobante', 'transferencia', 'tranfer√≠', 'transferi', 'envi√©', 'envie', 
      'pagu√©', 'pague', 'mand√©', 'mande', 'listo', 'hecho', 'transferido',
      'enviado', 'pagado', 'se√±a', 'se√±√©', 'sene'
    ]
    
    // Transfer-related patterns
    const transferPatterns = [
      /transfer√≠/i, /transferi/i, /transfir√≠/i, /transfiri/i,
      /envi√©/i, /envie/i, /mand√©/i, /mande/i,
      /pagu√©/i, /pague/i, /se√±√©/i, /sene/i,
      /ya est√°/i, /ya esta/i, /listo/i, /hecho/i
    ]
    
    // Check for keywords
    const hasReceiptKeyword = receiptKeywords.some(keyword => lowerInput.includes(keyword))
    
    // Check for patterns
    const hasTransferPattern = transferPatterns.some(pattern => pattern.test(input))
    
    // Check for monetary amounts (indicates payment)
    const hasAmount = /\$\d+|(\d+)\s*(pesos?|usd|dolares?)/i.test(input)
    
    return hasReceiptKeyword || hasTransferPattern || (hasAmount && lowerInput.includes('transfer'))
  }

  // Function to process transfer receipts
  private async processTransferReceipt(input: string, business: BusinessInfo, customerNumber: string, customerName?: string, context?: ConversationContext, transferNumber?: string | null): Promise<string> {
    // Si no hay contexto de reserva pendiente, pedir los datos primero
    if (!context?.reservation_day || !context?.reservation_people || !context?.customer_name) {
      // Si hay un n√∫mero de transferencia pero no hay reserva pendiente
      if (transferNumber) {
        return `¬°Hola! Recib√≠ tu n√∫mero de transferencia: **${transferNumber}**

Pero no tengo una reserva pendiente asociada a tu n√∫mero. 

Para confirmar tu reserva necesito que me digas:
üìÖ **¬øPara qu√© d√≠a?** (ej: s√°bado, lunes, 15/09)
üë• **¬øPara cu√°ntas personas?**
üçΩÔ∏è **¬øPara cena o baile?**

Una vez que tengas tu reserva pendiente, podr√© verificar tu transferencia con MercadoPago.`
      }
      
      // Preguntar por los datos de reserva primero
      return this.generateReservationRequest(business, customerName)
    }

    // Si no hay n√∫mero de transferencia, pedirlo
    if (!transferNumber) {
      const expectedAmount = 1000 * parseInt(context.reservation_people.toString())
      
      return `¬°Perfecto ${context.customer_name}! Para confirmar tu reserva:

üìÖ **${context.reservation_day.toUpperCase()}** ${context.reservation_time ? `a las ${context.reservation_time}` : ''}
üë• **${context.reservation_people} personas**
üí∞ **Se√±a requerida:** $${expectedAmount} (${context.reservation_people} x $1000)

üè¶ **Transfer√≠ a:** ${business.transfer_alias || 'alias.no.configurado'}

Una vez que hagas la transferencia, **enviame el n√∫mero de referencia o ID de la transferencia** para verificarla con MercadoPago.

Ejemplo: "12345678901" o "MP-ABC123XYZ"`
    }

    // *** VERIFICAR TRANSFERENCIA CON MERCADOPAGO ***
    console.log(`üîç Verificando transferencia ${transferNumber} con MercadoPago...`)
    
    const expectedAmount = 1000 * parseInt(context.reservation_people.toString())
    
    try {
      // Importar MercadoPagoService aqu√≠ para evitar dependencias circulares
      const { default: MercadoPagoService } = await import('../services/mercadoPagoService')
      const mercadoPagoService = new MercadoPagoService()
      
      // Verificar la transferencia
      const verificationResult = await mercadoPagoService.buscarPagoPorId(transferNumber)
      
      if (!verificationResult) {
        return `‚ùå **TRANSFERENCIA NO ENCONTRADA** ‚ùå

üîç No encontr√© ning√∫n pago con el ID: **${transferNumber}**

Verific√° que hayas copiado correctamente el n√∫mero de referencia de tu transferencia.

Si el problema persiste:
‚Ä¢ Revis√° el comprobante y enviame el ID correcto
‚Ä¢ Asegurate de haber transferido a: **${business.transfer_alias || 'alias.no.configurado'}**
‚Ä¢ Contactanos directamente: ${business.phone || business.email || 'contacto no disponible'}`
      }

      // Verificar el estado y monto
      const tolerance = process.env.NODE_ENV === 'development' ? 150000 : 100
      const isValid = mercadoPagoService.verificarPago(verificationResult, expectedAmount, tolerance)
      
      console.log(`üí∞ Verificaci√≥n MercadoPago:`)
      console.log(`   - ID: ${verificationResult.id}`)
      console.log(`   - Estado: ${verificationResult.status}`)
      console.log(`   - Monto: $${verificationResult.amount}`)
      console.log(`   - Esperado: $${expectedAmount}`)
      console.log(`   - V√°lido: ${isValid}`)
      
      if (!isValid) {
        const paymentInfo = mercadoPagoService.formatearInfoPago(verificationResult)
        
        return `‚ùå **PROBLEMA CON LA TRANSFERENCIA** ‚ùå

${paymentInfo}

üîç **Monto requerido:** $${expectedAmount} (${context.reservation_people} personas x $1000)

‚ö†Ô∏è **Problemas detectados:**
${verificationResult.status !== 'approved' ? `‚Ä¢ Estado: ${verificationResult.status} (debe estar aprobado)` : ''}
${Math.abs(verificationResult.amount - expectedAmount) > tolerance ? `‚Ä¢ Monto incorrecto: $${verificationResult.amount} (esperado: $${expectedAmount})` : ''}

Para confirmar tu reserva:
üè¶ Transfer√≠ exactamente **$${expectedAmount}** a: **${business.transfer_alias || 'alias.no.configurado'}**
üì± Y enviame el nuevo n√∫mero de referencia`
      }

      // *** TRANSFERENCIA VERIFICADA EXITOSAMENTE ***
      console.log(`‚úÖ Transferencia verificada exitosamente: ${transferNumber}`)
      
      // Guardar la reserva
      const reservationSaved = await this.saveReservation(
        business.id, 
        customerNumber, 
        context.customer_name, 
        context.reservation_day, 
        context.reservation_time || '', 
        context.reservation_type || 'cena', 
        context.reservation_people.toString()
      )

      if (reservationSaved) {
        // Limpiar el contexto - reserva confirmada
        await this.clearConversationContext(customerNumber, business.id)
        
        const paymentInfo = mercadoPagoService.formatearInfoPago(verificationResult)
        
        return `¬°EXCELENTE ${context.customer_name}! üéâ

‚úÖ **RESERVA CONFIRMADA** ‚úÖ

üìÖ **${context.reservation_day.toUpperCase()}** ${context.reservation_time ? `a las ${context.reservation_time}` : ''}
üë• **${context.reservation_people} personas**
üçΩÔ∏è **Para ${context.reservation_type || 'cena'}**

${paymentInfo}
üì± A nombre de: ${context.customer_name}
üìû Tel√©fono: ${customerNumber}

Te vamos a estar esperando en ${business.name}. 
¬°Nos vemos el ${context.reservation_day}! üçª

¬°Gracias por elegirnos! üôå`
      } else {
        const paymentInfo = mercadoPagoService.formatearInfoPago(verificationResult)
        
        return `‚úÖ **TRANSFERENCIA VERIFICADA** ‚úÖ

${paymentInfo}

‚ùó Pero hubo un problema t√©cnico al confirmar la reserva en el sistema.

Por favor contactanos directamente:
üìû ${business.phone || 'Tel√©fono no disponible'}
üìß ${business.email || 'Email no disponible'}

Tu transferencia est√° confirmada, solo necesitamos registrar la reserva manualmente.`
      }
      
    } catch (error: any) {
      console.error('Error verificando transferencia con MercadoPago:', error)
      
      return `‚ö†Ô∏è **ERROR VERIFICANDO TRANSFERENCIA** ‚ö†Ô∏è

Hubo un problema t√©cnico al verificar tu transferencia con MercadoPago.

üîç **ID enviado:** ${transferNumber}

Intent√° nuevamente en unos minutos o contactanos directamente:
üìû ${business.phone || 'Tel√©fono no disponible'}
üìß ${business.email || 'Email no disponible'}

**Error t√©cnico:** ${error?.message || 'Error desconocido'}`
    }
  }

  /**
   * Extract date from message with enhanced parsing - supports both exact dates and relative days
   */
  private extractDateFromMessage(messageText: string): string | null {
    const lowerInput = messageText.toLowerCase()
    
    // ========== 1. EXACT DATES (highest priority) ==========
    
    // Check for specific date patterns: "DD de MONTH"
    const dateWithMonthMatch = messageText.match(/(\d{1,2})\s+de\s+(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i)
    if (dateWithMonthMatch) {
      const day = dateWithMonthMatch[1]
      const month = dateWithMonthMatch[2].toLowerCase()
      return `${day} de ${month}`
    }
    
    // Check for "para el XX de MONTH"
    const paraElMatch = messageText.match(/para\s+el\s+(\d{1,2})\s+de\s+(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i)
    if (paraElMatch) {
      const day = paraElMatch[1]
      const month = paraElMatch[2].toLowerCase()
      return `${day} de ${month}`
    }
    
    // ========== 2. RELATIVE DAYS WITH CONTEXT ==========
    
    // LUNES variants
    if (lowerInput.includes('lunes que viene') || lowerInput.includes('pr√≥ximo lunes') || lowerInput.includes('proximo lunes')) {
      return 'lunes que viene'
    } else if (lowerInput.includes('este lunes')) {
      return 'lunes'
    }
    
    // MARTES variants  
    if (lowerInput.includes('martes que viene') || lowerInput.includes('pr√≥ximo martes') || lowerInput.includes('proximo martes')) {
      return 'martes que viene'
    } else if (lowerInput.includes('este martes')) {
      return 'martes'
    }
    
    // MI√âRCOLES variants
    if (lowerInput.includes('mi√©rcoles que viene') || lowerInput.includes('miercoles que viene') || 
        lowerInput.includes('pr√≥ximo mi√©rcoles') || lowerInput.includes('proximo miercoles')) {
      return 'mi√©rcoles que viene'
    } else if (lowerInput.includes('este mi√©rcoles') || lowerInput.includes('este miercoles')) {
      return 'mi√©rcoles'
    }
    
    // JUEVES variants
    if (lowerInput.includes('jueves que viene') || lowerInput.includes('pr√≥ximo jueves') || lowerInput.includes('proximo jueves')) {
      return 'jueves que viene'
    } else if (lowerInput.includes('este jueves')) {
      return 'jueves'
    }
    
    // VIERNES variants
    if (lowerInput.includes('viernes que viene') || lowerInput.includes('pr√≥ximo viernes') || lowerInput.includes('proximo viernes')) {
      return 'viernes que viene'
    } else if (lowerInput.includes('este viernes')) {
      return 'viernes'
    }
    
    // S√ÅBADO variants
    if (lowerInput.includes('s√°bado que viene') || lowerInput.includes('sabado que viene') || 
        lowerInput.includes('pr√≥ximo s√°bado') || lowerInput.includes('proximo sabado')) {
      return 's√°bado que viene'
    } else if (lowerInput.includes('este s√°bado') || lowerInput.includes('este sabado')) {
      return 's√°bado'
    }
    
    // DOMINGO variants
    if (lowerInput.includes('domingo que viene') || lowerInput.includes('pr√≥ximo domingo') || lowerInput.includes('proximo domingo')) {
      return 'domingo que viene'
    } else if (lowerInput.includes('este domingo')) {
      return 'domingo'
    }
    
    // ========== 3. SIMPLE DAY NAMES (with word boundaries) ==========
    const daysOfWeek = ['domingo', 'lunes', 'martes', 'mi√©rcoles', 'miercoles', 'jueves', 'viernes', 's√°bado', 'sabado']
    
    for (const day of daysOfWeek) {
      // Use word boundaries to avoid false positives (like "viernes" in "septiembre")
      const dayRegex = new RegExp(`\\b${day}\\b`, 'i')
      if (dayRegex.test(messageText)) {
        // Normalize miercoles -> mi√©rcoles, sabado -> s√°bado
        if (day === 'miercoles') return 'mi√©rcoles'
        if (day === 'sabado') return 's√°bado'
        return day
      }
    }
    
    // ========== 4. RELATIVE DATES ==========
    if (lowerInput.includes('ma√±ana') || lowerInput.includes('manana')) {
      return 'ma√±ana'
    } else if (lowerInput.includes('hoy')) {
      return 'hoy'
    }
    
    return null
  }

  /**
   * Generar solicitud de datos de reserva
   */
  private generateReservationRequest(business: BusinessInfo, customerName?: string): string {
    const greeting = customerName ? `¬°Hola ${customerName}! ` : '¬°Hola! '
    
    return `${greeting}¬°Perfecto para hacer tu reserva! üçΩÔ∏è

Para confirmar necesito que me digas:

üìÖ **¬øPara qu√© d√≠a?** 
   Ejemplo: "s√°bado", "15 de septiembre", "ma√±ana"

ÔøΩ **¬øPara cu√°ntas personas?**
   Ejemplo: "4 personas", "somos 6"

üçΩÔ∏è **¬øPara cena o baile?**
   ‚Ä¢ Cena: hasta las 23:00hs
   ‚Ä¢ Baile: despu√©s de las 23:00hs

üí∞ **Se√±a:** $1 por persona
üè¶ **CBU/Alias:** ${business.transfer_alias || 'alias.no.configurado'}

¬°Enviame esos datos y te confirmo la reserva al toque! üéâ`
  }

}